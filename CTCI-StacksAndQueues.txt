3.1 Three in One
Divisions: Divide the array into 3 parts. Each part represents a stack. Keep a currIndex for
all three parts of the array, as each index represents the top of the stack, and increment or
decrement depending on whether or not you are pushing or popping. If you run out of space for an
array, double the size of the array, and redistribute the array, amortized O(1) push and pop.

3.2 Stack Min
Keep the min value of the stack (so far) at every node. For example, when you pop, the min-value
associated with that stack node is the min for all the elements below. When you push, you compare
the value with the min value of the top of the stack (peek), and then set the min to that value if
its less than that.

(see E155-MinStack.java)

3.3 Stack of Plates
use an ArrayList of stacks to keep track of all the stacks. You also want to keep a separate
ArrayList of sizes for each stack? You also want a variable to keep track of the capacity of
each stack to see if its full, and you also want to keep a variable to the last stack (or not
because an ArrayList can dynamically resize).

FOLLOW-UP: PopAt()
There are two scenarios for this, both are possible:
1. You popAt a certain index, so you pop the stack at the index and update the size and leave it
just like that. Many stacks will not be at capacity.

2. You have a rollover system, where if you pop at a certain index, you want to rollover all the
other elements from the stacks after that, which can be extremely expensive, and will cause you
to also have to add a bottom variable for each stack, and all the bottom variables must have a
next field in order to be able to update itself.

3.4 Queue via Stacks

(see E232-QueueViaStacks)

Also do: Stack via Queue:
(see E225-StacksViaQueues)
